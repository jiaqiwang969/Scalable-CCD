\documentclass[11pt]{ctexart}
\usepackage{geometry}
\geometry{a4paper,margin=2.2cm}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{siunitx}
\usepackage{longtable}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}
\hypersetup{colorlinks=true,linkcolor=blue,urlcolor=magenta}
\title{Scalable CCD：CUDA 与 Metal 宽阶段性能对比报告}
\author{自动生成}
\date{\today}
\begin{document}
\maketitle

\section{实验概述}

本报告对比了 Scalable CCD 库在 CUDA（NVIDIA GPU）和 Metal（Apple Silicon）两种后端下的宽阶段（Broad Phase）碰撞检测性能。

\subsection{测试环境}

\begin{table}[htbp]
    \centering
    \caption{硬件配置对比}
    \label{tab:hardware}
    \begin{tabular}{llll}
        \toprule
        后端 & 设备 & GPU 核心/着色器 & 显存/统一内存 \\
        \midrule
        \multirow{2}{*}{CUDA} & NVIDIA RTX 3090 & 10496 CUDA Cores & 24 GB GDDR6X \\
         & NVIDIA RTX 2000 Ada & 3072 CUDA Cores & 8 GB \\
        \midrule
        Metal & Apple M4 Max & 40 GPU Cores & 统一内存架构 \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{测试方法}
\begin{itemize}
    \item CUDA：使用 Catch2 测试框架，通过 \texttt{--durations yes} 获取壁钟时间
    \item Metal：使用独立性能测试程序 \texttt{test\_performance\_metal2}，输出 JSON 格式结果
    \item 所有测试均包含：mesh 文件读取、AABB 包围盒构建、VF（顶点-面）检测、EE（边-边）检测
    \item Metal 使用 STQ（Sweep and Tiniest Queue）算法，CUDA 使用标准 SAP（Sweep and Prune）
\end{itemize}

\section{性能对比}

\subsection{宽阶段总耗时}

表~\ref{tab:broadphase} 汇总了三个测试场景的宽阶段总耗时（毫秒），包含文件读取、AABB 构建和两次碰撞检测（VF + EE）。

\begin{table}[htbp]
    \centering
    \caption{宽阶段总耗时对比（毫秒）}
    \label{tab:broadphase}
    \begin{tabular}{lrrrrr}
        \toprule
        场景 & RTX 3090 & RTX 2000 Ada & M4 Max & M4 vs 3090 & M4 vs 2000Ada \\
        \midrule
        Armadillo-Rollers & 6,943 & 9,873 & 2,131 & \textcolor{green}{\textbf{3.3×}} & \textcolor{green}{\textbf{4.6×}} \\
        Cloth-Funnel & 274 & 218 & 286 & 0.96× & 0.76× \\
        N-Body & 17,911 & 22,729 & 22,910 & 0.78× & 0.99× \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{碰撞对数量}

表~\ref{tab:pairs} 展示了每个场景检测到的碰撞候选对数量。

\begin{table}[htbp]
    \centering
    \caption{碰撞候选对数量}
    \label{tab:pairs}
    \begin{tabular}{lrrrr}
        \toprule
        场景 & VF 对（Metal） & EE 对（Metal） & VF 真正例 & EE 真正例 \\
        \midrule
        Armadillo-Rollers & 2,031,902 & 5,068,080 & 4,652 & 19,313 \\
        Cloth-Funnel & 7,319 & 33,770 & 92 & 263 \\
        N-Body & 9,396,388 & 22,366,873 & 9,460 & 41,036 \\
        \bottomrule
    \end{tabular}
\end{table}

注：Metal 报告的是宽阶段原始候选对数量，"真正例"是经过窄阶段验证后的实际碰撞数量。

\subsection{GPU 内核时间分析（Metal）}

Metal 后端提供了更细粒度的 GPU 计时数据：

\begin{table}[htbp]
    \centering
    \caption{Metal GPU 内核耗时（毫秒）}
    \label{tab:metal_gpu}
    \begin{tabular}{lrrrr}
        \toprule
        场景 & VF Total & EE Total & STQ 内核 & YZ Filter \\
        \midrule
        Armadillo-Rollers & 786.5 & 1,335.7 & 46.3 & 3.7 \\
        Cloth-Funnel & 132.2 & 150.2 & 24.4 & 1.3 \\
        N-Body & 9,101.4 & 13,771.4 & 256.1 & 30.6 \\
        \bottomrule
    \end{tabular}
\end{table}

\section{分析与结论}

\subsection{性能特点}

\begin{enumerate}
    \item \textbf{中等规模场景（Armadillo-Rollers）}：Metal M4 Max 表现最佳，比 RTX 3090 快 3.3 倍，比 RTX 2000 Ada 快 4.6 倍。这得益于：
    \begin{itemize}
        \item Apple Silicon 统一内存架构避免了 CPU-GPU 数据传输开销
        \item Metal STQ 算法的持久线程设计更适合中等规模数据
    \end{itemize}

    \item \textbf{小规模场景（Cloth-Funnel）}：三者性能相近，Metal 略慢。小数据量下 GPU 初始化开销占比较高。

    \item \textbf{大规模场景（N-Body）}：NVIDIA RTX 3090 表现最佳，Metal 与 RTX 2000 Ada 接近。原因：
    \begin{itemize}
        \item N-Body 产生 2200 万+ 碰撞对，Metal 需要多次动态扩展缓冲区
        \item RTX 3090 的 24GB 显存和更高带宽在大数据集上优势明显
    \end{itemize}
\end{enumerate}

\subsection{算法差异}

\begin{itemize}
    \item \textbf{CUDA SAP}：传统 Sweep-and-Prune，适合大规模并行
    \item \textbf{Metal STQ}：Sweep and Tiniest Queue，使用工作窃取队列，动态负载均衡
    \item Metal 的 STQ 内核时间（46-256ms）远小于总时间，说明主要开销在数据准备和后处理
\end{itemize}

\subsection{结论}

\begin{enumerate}
    \item Metal M4 Max 在中等规模场景下性能优异，比 NVIDIA GPU 快 3-5 倍
    \item 大规模场景（千万级碰撞对）下，NVIDIA RTX 3090 凭借更大显存和带宽占优
    \item Metal 实现已成功移植，功能正确性已通过 ground-truth 验证
    \item 两种后端适用于不同场景，可根据硬件平台选择
\end{enumerate}

\section{附录：测试数据详情}

\subsection{JSON 输出示例}

\textbf{Metal 结果格式：}
\begin{verbatim}
{
  "backend": "metal",
  "device": "Apple M4 Max",
  "section": "N-Body",
  "vf_pairs": 9396388,
  "ee_pairs": 22366873,
  "host_total_ms": 22910.400,
  "vf_stq_ms": 256.148,
  "ee_stq_ms": 256.148
}
\end{verbatim}

\textbf{CUDA 结果格式：}
\begin{verbatim}
{
  "backend": "cuda",
  "device": "NVIDIA GeForce RTX 3090",
  "section": "N-Body",
  "vf_pairs": 9460,
  "ee_pairs": 41036,
  "host_total_ms": 17911.0,
  "gpu_ms": 17911.0
}
\end{verbatim}

\subsection{测试命令}

\textbf{CUDA：}
\begin{verbatim}
python tests/export_cuda_results.py \
  --device "0:rtx2000ada:NVIDIA RTX 2000 Ada Generation Laptop GPU" \
  --device "1:rtx3090:NVIDIA GeForce RTX 3090"
\end{verbatim}

\textbf{Metal：}
\begin{verbatim}
./build/tests/test_performance_metal2
\end{verbatim}

\end{document}
